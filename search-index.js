var searchIndex = JSON.parse('{\
"bytemuck":{"doc":"This crate gives small utilities for casting between plain …","t":"NICIQSSINIEINNIIILLFFFFFFFALLLLLFFLLLLLLOOLLLLLLLLLLFFFFFFFFLFFLFLLLLLLLLLLLLLQIENNLLFFFFFLLLLLLFFLLKFFFFFFLFFLFL","n":["AlignmentMismatch","AnyBitPattern","CheckedBitPattern","Contiguous","Int","MAX_VALUE","MIN_VALUE","NoUninit","OutputSliceWouldHaveSlop","Pod","PodCastError","PodInOption","SizeMismatch","TargetAlignmentGreaterAndInputNotAligned","TransparentWrapper","Zeroable","ZeroableInOption","borrow","borrow_mut","bytes_of","bytes_of_mut","cast","cast_mut","cast_ref","cast_slice","cast_slice_mut","checked","clone","eq","fmt","fmt","from","from_bytes","from_bytes_mut","from_integer","from_integer","hash","into","into_integer","into_integer","offset_of","offset_of","peel","peel","peel_mut","peel_mut","peel_ref","peel_ref","peel_slice","peel_slice","peel_slice_mut","peel_slice_mut","pod_align_to","pod_align_to_mut","pod_read_unaligned","try_cast","try_cast_mut","try_cast_ref","try_cast_slice","try_cast_slice_mut","try_from","try_from_bytes","try_from_bytes_mut","try_into","try_pod_read_unaligned","type_id","wrap","wrap","wrap_mut","wrap_mut","wrap_ref","wrap_ref","wrap_slice","wrap_slice","wrap_slice_mut","wrap_slice_mut","zeroed","zeroed","Bits","CheckedBitPattern","CheckedCastError","InvalidBitPattern","PodCastError","borrow","borrow_mut","cast","cast_mut","cast_ref","cast_slice","cast_slice_mut","clone","eq","fmt","fmt","from","from","from_bytes","from_bytes_mut","hash","into","is_valid_bit_pattern","pod_read_unaligned","try_cast","try_cast_mut","try_cast_ref","try_cast_slice","try_cast_slice_mut","try_from","try_from_bytes","try_from_bytes_mut","try_into","try_pod_read_unaligned","type_id"],"q":[[0,"bytemuck"],[78,"bytemuck::checked"]],"d":["For this type of cast the alignments must be exactly the …","Marker trait for “plain old data” types that are valid …","","A trait indicating that:","The primitive integer type with an identical …","The upper <em>inclusive</em> bound for valid instances of this type.","The lower <em>inclusive</em> bound for valid instances of this type.","Marker trait for “plain old data” types with no uninit …","If the element size changes then the output slice changes …","Marker trait for “plain old data”.","The things that can go wrong when casting between <code>Pod</code> data …","Trait for types which are Pod when wrapped in Option.","When casting a slice you can’t convert between ZST …","You tried to cast a slice to an element type with a higher …","A trait which indicates that a type is a …","Trait for types that can be safely created with <code>zeroed</code>.","Trait for types which are Zeroable when wrapped in Option.","","","Re-interprets <code>&amp;T</code> as <code>&amp;[u8]</code>.","Re-interprets <code>&amp;mut T</code> as <code>&amp;mut [u8]</code>.","Cast <code>T</code> into <code>U</code>","Cast <code>&amp;mut T</code> into <code>&amp;mut U</code>.","Cast <code>&amp;T</code> into <code>&amp;U</code>.","Cast <code>&amp;[A]</code> into <code>&amp;[B]</code>.","Cast <code>&amp;mut [T]</code> into <code>&amp;mut [U]</code>.","Checked versions of the casting functions exposed in crate …","","","","","Returns the argument unchanged.","Re-interprets <code>&amp;[u8]</code> as <code>&amp;T</code>.","Re-interprets <code>&amp;mut [u8]</code> as <code>&amp;mut T</code>.","If <code>value</code> is within the range for valid instances of this …","If <code>value</code> is within the range for valid instances of this …","","Calls <code>U::from(self)</code>.","Perform the conversion from <code>C</code> into the underlying integral …","Perform the conversion from <code>C</code> into the underlying integral …","Find the offset in bytes of the given <code>$field</code> of <code>$Type</code>. …","Find the offset in bytes of the given <code>$field</code> of <code>$Type</code>. …","Convert the wrapper type into the inner type.","Convert the wrapper type into the inner type.","Convert a mutable reference to the wrapper type into a …","Convert a mutable reference to the wrapper type into a …","Convert a reference to the wrapper type into a reference …","Convert a reference to the wrapper type into a reference …","Convert a slice to the wrapped type into a slice to the …","Convert a slice to the wrapped type into a slice to the …","Convert a mutable slice to the wrapped type into a mutable …","Convert a mutable slice to the wrapped type into a mutable …","As <code>align_to</code>, but safe because of the <code>Pod</code> bound.","As <code>align_to_mut</code>, but safe because of the <code>Pod</code> bound.","Reads the slice into a <code>T</code> value.","Try to cast <code>T</code> into <code>U</code>.","Try to convert a <code>&amp;mut T</code> into <code>&amp;mut U</code>.","Try to convert a <code>&amp;T</code> into <code>&amp;U</code>.","Try to convert <code>&amp;[A]</code> into <code>&amp;[B]</code> (possibly with a change in …","Try to convert <code>&amp;mut [A]</code> into <code>&amp;mut [B]</code> (possibly with a …","","Re-interprets <code>&amp;[u8]</code> as <code>&amp;T</code>.","Re-interprets <code>&amp;mut [u8]</code> as <code>&amp;mut T</code>.","","Reads from the bytes as if they were a <code>T</code>.","","Convert the inner type into the wrapper type.","Convert the inner type into the wrapper type.","Convert a mutable reference to the inner type into a …","Convert a mutable reference to the inner type into a …","Convert a reference to the inner type into a reference to …","Convert a reference to the inner type into a reference to …","Convert a slice to the inner type into a slice to the …","Convert a slice to the inner type into a slice to the …","Convert a mutable slice to the inner type into a mutable …","Convert a mutable slice to the inner type into a mutable …","Calls <code>zeroed</code>.","Calls <code>zeroed</code>.","<code>Self</code> <em>must</em> have the same layout as the specified <code>Bits</code> …","A marker trait that allows types that have some invalid …","The things that can go wrong when casting between …","When casting to a <code>CheckedBitPattern</code> type, it is possible …","An error occurred during a true-<code>Pod</code> cast","","","Cast <code>T</code> into <code>U</code>","Cast <code>&amp;mut T</code> into <code>&amp;mut U</code>.","Cast <code>&amp;T</code> into <code>&amp;U</code>.","Cast <code>&amp;[A]</code> into <code>&amp;[B]</code>.","Cast <code>&amp;mut [T]</code> into <code>&amp;mut [U]</code>.","","","","","","Returns the argument unchanged.","Re-interprets <code>&amp;[u8]</code> as <code>&amp;T</code>.","Re-interprets <code>&amp;mut [u8]</code> as <code>&amp;mut T</code>.","","Calls <code>U::from(self)</code>.","If this function returns true, then it must be valid to …","Reads the slice into a <code>T</code> value.","Try to cast <code>T</code> into <code>U</code>.","Try to convert a <code>&amp;mut T</code> into <code>&amp;mut U</code>.","Try to convert a <code>&amp;T</code> into <code>&amp;U</code>.","Try to convert <code>&amp;[A]</code> into <code>&amp;[B]</code> (possibly with a change in …","Try to convert <code>&amp;mut [A]</code> into <code>&amp;mut [B]</code> (possibly with a …","","Re-interprets <code>&amp;[u8]</code> as <code>&amp;T</code>.","Re-interprets <code>&amp;mut [u8]</code> as <code>&amp;mut T</code>.","","Reads from the bytes as if they were a <code>T</code>.",""],"i":[5,0,0,0,16,16,16,0,5,0,0,0,5,5,0,0,0,5,5,0,0,0,0,0,0,0,0,5,5,5,5,5,0,0,16,16,5,5,16,16,0,0,17,17,17,17,17,17,17,17,17,17,0,0,0,0,0,0,0,0,5,0,0,5,0,5,17,17,17,17,17,17,17,17,17,17,18,18,14,0,0,15,15,15,15,0,0,0,0,0,15,15,15,15,15,15,0,0,15,15,14,0,0,0,0,0,0,15,0,0,15,0,15],"f":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,[[]],[[]],[1,[[3,[2]]]],[[[0,[1,4]]],[[3,[2]]]],[1,4],[[[0,[1,4]]],[[0,[1,4]]]],[1,4],[[[3,[1]]],[[3,[4]]]],[[[3,[[0,[1,4]]]]],[[3,[[0,[1,4]]]]]],0,[5,5],[[5,5],6],[[5,7],8],[[5,7],8],[[]],[[[3,[2]]],4],[[[3,[2]]],[[0,[1,4]]]],[[],9],[[],9],[[5,10]],[[]],[[]],[[]],0,0,[11,11],[11,11],[[]],[[]],[[]],[[]],[[[3,[11]]],[[3,[11]]]],[[[3,[11]]],[[3,[11]]]],[[[3,[11]]],[[3,[11]]]],[[[3,[11]]],[[3,[11]]]],[[[3,[1]]]],[[[3,[[0,[1,4]]]]]],[[[3,[2]]],4],[1,[[12,[4,5]]]],[[[0,[1,4]]],[[12,[[0,[1,4]],5]]]],[1,[[12,[4,5]]]],[[[3,[1]]],[[12,[[3,[4]],5]]]],[[[3,[[0,[1,4]]]]],[[12,[[3,[[0,[1,4]]]],5]]]],[[],12],[[[3,[2]]],[[12,[4,5]]]],[[[3,[2]]],[[12,[[0,[1,4]],5]]]],[[],12],[[[3,[2]]],[[12,[4,5]]]],[[],13],[11,11],[11,11],[[]],[[]],[[]],[[]],[[[3,[11]]],[[3,[11]]]],[[[3,[11]]],[[3,[11]]]],[[[3,[11]]],[[3,[11]]]],[[[3,[11]]],[[3,[11]]]],[[]],[[]],0,0,0,0,0,[[]],[[]],[1,14],[[[0,[1,4]]],[[0,[1,14]]]],[1,14],[[[3,[1]]],[[3,[14]]]],[[[3,[[0,[1,4]]]]],[[3,[[0,[1,14]]]]]],[15,15],[[15,15],6],[[15,7],8],[[15,7],8],[5,15],[[]],[[[3,[2]]],14],[[[3,[2]]],[[0,[1,14]]]],[[15,10]],[[]],[[],6],[[[3,[2]]],14],[1,[[12,[14,15]]]],[[[0,[1,4]]],[[12,[[0,[14,1]],15]]]],[1,[[12,[14,15]]]],[[[3,[1]]],[[12,[[3,[14]],15]]]],[[[3,[[0,[1,4]]]]],[[12,[[3,[[0,[14,1]]]],15]]]],[[],12],[[[3,[2]]],[[12,[14,15]]]],[[[3,[2]]],[[12,[[0,[14,1]],15]]]],[[],12],[[[3,[2]]],[[12,[14,15]]]],[[],13]],"c":[],"p":[[8,"NoUninit"],[15,"u8"],[15,"slice"],[8,"AnyBitPattern"],[4,"PodCastError"],[15,"bool"],[3,"Formatter"],[6,"Result"],[4,"Option"],[8,"Hasher"],[8,"Sized"],[4,"Result"],[3,"TypeId"],[8,"CheckedBitPattern"],[4,"CheckedCastError"],[8,"Contiguous"],[8,"TransparentWrapper"],[8,"Zeroable"]]},\
"randomize":{"doc":"Pseudo-random number generator crate.","t":"DDIDDSSSSSSSSSSSSLLLLLLLLLLLLLLLLLLLLLLMLLLLALLLLLLMLLLLLLLLLLLLKLLLLLLLLMMLLLLLLLLLLLLLLRFFFFFFFFFFF","n":["BoundedRandU16","BoundedRandU32","Gen32","PCG32","PCG32K","_10","_10","_12","_12","_20","_20","_4","_4","_6","_6","_8","_8","borrow","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","borrow_mut","clone","clone","clone","clone","count","count","d10","d12","d20","d4","d6","d8","eq","eq","ext","fmt","fmt","fmt","fmt","formulas","from","from","from","from","hash","hash","inc","into","into","into","into","jump","new","new","new","new","next_bool","next_f32_unit","next_i32","next_u32","next_u32","next_u32","next_u32","next_u32","place_in_range","place_in_range","sample","sample","state","state","try_from","try_from","try_from","try_from","try_into","try_into","try_into","try_into","try_new","try_new","type_id","type_id","type_id","type_id","PCG_MUL_64","ieee754_random_f32","ieee754_random_f64","lcg128_jump","lcg128_step","lcg32_jump","lcg32_step","lcg64_jump","lcg64_step","next_binary_exp_distr32","xsh_rr_u64_to_u32","xsl_rr_u128_to_u64"],"q":[[0,"randomize"],[89,"randomize::formulas"]],"d":["Allows sampling a <code>u16</code> number in <code>0 .. N</code>.","Allows sampling a <code>u32</code> number in <code>0 .. N</code>.","A trait for pseudo-random number generators with 32-bit …","A Permuted Congruential Generator with 32-bit output.","A Permuted Congruential Generator with 32-bit output, …","","","","","","","","","","","","","","","","","","","","","","","","","The number of possible outputs.","The number of possible outputs.","Gives a value in the range <code>1 ..= 10</code>","Gives a value in the range <code>1 ..= 12</code>","Gives a value in the range <code>1 ..= 20</code>","Gives a value in the range <code>1 ..= 4</code>","Gives a value in the range <code>1 ..= 6</code>","Gives a value in the range <code>1 ..= 8</code>","","","The generator’s extension array. The generator’s base …","","","","","Base formulas used elsewhere in the crate.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","","","The generator’s increment.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Jump the generator the given number of steps forward in …","Creates a new generator by directly using the value given.","Creates a new generator by directly using the value given.","Constructs a new value.","Constructs a new value.","Gives a uniformly distributed value.","Gives a value in the range <code>0.0 ..= 1.0</code>","Gives a uniformly distributed value.","Makes the generator create the next output.","","Generate the next <code>u32</code> in the sequence.","","Generate the next <code>u32</code> in the sequence.","Given a <code>u32</code>, try to place it into this bounded range.","Given a <code>u16</code>, try to place it into this bounded range.","Given a generator function, call it until <code>place_in_range</code> …","Given a generator function, call it until <code>place_in_range</code> …","The generator’s state.","The generator’s state.","","","","","","","","","Constructs a new value, or <code>None</code> on failure.","Constructs a new value, or <code>None</code> on failure.","","","","","This is the suggested multiplier for a PCG with 64 bits of …","Generates an <code>f32</code> in the signed or unsigned unit range.","Generates an <code>f64</code> in the signed or unsigned unit range.","Advance a 32-bit LCG by <code>delta</code> steps in <code>log2(delta)</code> time.","Advance a 32-bit LCG’s state.","Advance a 32-bit LCG by <code>delta</code> steps in <code>log2(delta)</code> time.","Advance a 32-bit LCG’s state.","Advance a 32-bit LCG by <code>delta</code> steps in <code>log2(delta)</code> time.","Advance a 32-bit LCG’s state.","Returns <code>k</code> with probability <code>2^(-k-1)</code>, a “binary …","“Xor-shift high bits” then “randomized rotate”, <code>u64</code>…","“Xor-shift low bits” then “randomized rotate”, <code>u128</code>…"],"i":[0,0,0,0,0,3,4,3,4,3,4,3,4,3,4,3,4,1,2,3,4,1,2,3,4,1,2,3,4,3,4,21,21,21,21,21,21,3,4,2,1,2,3,4,0,1,2,3,4,3,4,1,1,2,3,4,1,1,2,3,4,21,21,21,21,1,1,2,2,3,4,3,4,1,2,1,2,3,4,1,2,3,4,3,4,1,2,3,4,0,0,0,0,0,0,0,0,0,0,0,0],"f":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[1,1],[2,2],[3,3],[4,4],[3,5],[4,6],[[],7],[[],7],[[],7],[[],7],[[],7],[[],7],[[3,3],8],[[4,4],8],0,[[1,9],10],[[2,9],10],[[3,9],10],[[4,9],10],0,[[]],[[]],[[]],[[]],[[3,11]],[[4,11]],0,[[]],[[]],[[]],[[]],[[1,12]],[[12,12],1],[[12,[13,[5]]],2],[5,3],[6,4],[[],8],[[],14],[[],7],[[],5],[1,5],[1,5],[2,5],[2,5],[[3,5],[[15,[5]]]],[[4,6],[[15,[6]]]],[[3,16],5],[[4,16],6],0,0,[[],17],[[],17],[[],17],[[],17],[[],17],[[],17],[[],17],[[],17],[5,[[15,[3]]]],[6,[[15,[4]]]],[[],18],[[],18],[[],18],[[],18],0,[[16,8],14],[[16,8],19],[[20,20,20,20],20],[[20,20,20],20],[[5,5,5,5],5],[[5,5,5],5],[[12,12,12,12],12],[[12,12,12],12],[16,5],[12,5],[20,12]],"c":[],"p":[[3,"PCG32"],[3,"PCG32K"],[3,"BoundedRandU32"],[3,"BoundedRandU16"],[15,"u32"],[15,"u16"],[15,"i32"],[15,"bool"],[3,"Formatter"],[6,"Result"],[8,"Hasher"],[15,"u64"],[15,"array"],[15,"f32"],[4,"Option"],[8,"FnMut"],[4,"Result"],[3,"TypeId"],[15,"f64"],[15,"u128"],[8,"Gen32"]]}\
}');
if (typeof window !== 'undefined' && window.initSearch) {window.initSearch(searchIndex)};
if (typeof exports !== 'undefined') {exports.searchIndex = searchIndex};
